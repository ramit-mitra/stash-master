(window.webpackJsonp=window.webpackJsonp||[]).push([[372],{1116:function(e,n){e.exports="---\ntitle: Short-lived Branches\n---\n\n\x3c!-- sonarqube --\x3e\n\n_Branch analysis is available as part of [Developer Edition](https://redirect.sonarsource.com/editions/developer.html)_\n\n\x3c!-- /sonarqube --\x3e\n\n## Status vs Quality Gate\n\nFor short-lived branches, there is a kind of hard-coded quality gate focusing only on new issues. Its status is reflected by the green|red signal associated with each short-lived branch:\n\n* status: green / OK or red / ERROR\n* error conditions:\n\n  * new open bugs > 0\n  * new open vulnerabilities > 0\n  * new open code smells > 0\n\nIt is possible to change the status of a short-lived branch from ERROR to OK (red to green), i.e. mergable, by manually confirming the issues. The same is true for the False-Positive and Won't Fix statuses.\nIt means the status of a short-lived branch will be red only when there are Open issues in the branch.\n\n## Issue Creation and Synchronization\n\nThe issues visible on the short-lived branch are the new issues corresponding to files modified in the branch.\n\nModified files are determined based on the checksum of each file on the sonar.branch.target and the short-lived branch.\n\n## Leak Period\n\nThe ephemeral nature of short-lived branches means no explicit Leak Period is necessary; it's all new code. Thus, no \"new code\" data is available for a short-lived branch.\n\n## Settings and Quality Profiles on Branches\n\nBranch settings and quality profiles default to those set for the master branch, and by design, it's not possible to configure other values.\n\n## Known Limitations\n\n* Only the number of bugs, code smells, vulnerabilities and files are computed. As a consequence, you have no way to get a Quality Gate status as such on short-lived branch.\n* You cannot connect SonarLint to a short-lived branch.\n* Analysis of a short-lived branch based on another short-lived branch is not supported.\n"}}]);
//# sourceMappingURL=372.3d644081.chunk.js.map